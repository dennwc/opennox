<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1">
    <title>Emscripten-Generated Code</title>
    <style>
      body {
        font-family: arial;
        margin: 0;
        padding: none;
      }

      .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
      div.emscripten { text-align: center; }      
      div.emscripten_border { border: 1px solid black; }
      /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
      canvas.emscripten { border: 0px none; background-color: black; }

      #emscripten_logo {
        display: inline-block;
        margin: 0;
      }

      .spinner {
        height: 30px;
        width: 30px;
        margin: 0;
        margin-top: 20px;
        margin-left: 20px;
        display: inline-block;
        vertical-align: top;

        -webkit-animation: rotation .8s linear infinite;
        -moz-animation: rotation .8s linear infinite;
        -o-animation: rotation .8s linear infinite;
        animation: rotation 0.8s linear infinite;

        border-left: 5px solid rgb(235, 235, 235);
        border-right: 5px solid rgb(235, 235, 235);
        border-bottom: 5px solid rgb(235, 235, 235);
        border-top: 5px solid rgb(120, 120, 120);
        
        border-radius: 100%;
        background-color: rgb(189, 215, 46);
      }

      @-webkit-keyframes rotation {
        from {-webkit-transform: rotate(0deg);}
        to {-webkit-transform: rotate(360deg);}
      }
      @-moz-keyframes rotation {
        from {-moz-transform: rotate(0deg);}
        to {-moz-transform: rotate(360deg);}
      }
      @-o-keyframes rotation {
        from {-o-transform: rotate(0deg);}
        to {-o-transform: rotate(360deg);}
      }
      @keyframes rotation {
        from {transform: rotate(0deg);}
        to {transform: rotate(360deg);}
      }

      #status {
        display: inline-block;
        vertical-align: top;
        margin-top: 30px;
        margin-left: 20px;
        font-weight: bold;
        color: rgb(120, 120, 120);
      }

      #progress {
        height: 20px;
        width: 300px;
      }

      #controls {
        display: inline-block;
        float: right;
        vertical-align: top;
        margin-top: 30px;
        margin-right: 20px;
      }

      #output {
        width: 100%;
        height: 200px;
        margin: 0 auto;
        margin-top: 10px;
        border-left: 0px;
        border-right: 0px;
        padding-left: 0px;
        padding-right: 0px;
        display: block;
        background-color: black;
        color: white;
        font-family: 'Lucida Console', Monaco, monospace;
        outline: none;
      }

      #canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <div class="spinner" id='spinner'></div>
    <div class="emscripten" id="status">Downloading...</div>

<!--
<span id='controls'>
  <span><input type="checkbox" id="resize">Resize canvas</span>
  <span><input type="checkbox" id="pointerLock" checked>Lock/hide mouse pointer &nbsp;&nbsp;&nbsp;</span>
  <span><input type="button" value="Fullscreen" onclick="doFullscreen()">
  </span>
</span>
-->

    <div class="emscripten">
      <progress value="0" max="100" id="progress" hidden=1></progress>
    </div>

    
    <div class="emscripten_border">
      <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex=-1></canvas>
    </div>
    <!-- <textarea id="output" rows="8"></textarea> -->

    <div id="warning">
      <h3>The game must first download and save 200 MB of assets. Do you wish to continue?</h3> 
      <h4>(This will be your only warning.)</h4>
      <button onclick="doit()">Yes, I like data.</button>
    </div>

    <script type='text/javascript' src="hangul.min.js"></script>
    <script type='text/javascript'>
      var statusElement = document.getElementById('status');
      var progressElement = document.getElementById('progress');
      var spinnerElement = document.getElementById('spinner');

function loadShader(gl, str, type) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

    function compileShader(gl, fragmentShader, vertexShader) {
      shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);

      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
      }

      gl.useProgram(shaderProgram);
      shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
      gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
      shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
      shaderProgram.rotMatrixUniform = gl.getUniformLocation(shaderProgram, "rotMatrix");

      return shaderProgram;
    }


    function initShaders(gl) {
        var shaderPrefilterStr = '\
            varying vec2 vTextureCoord;                                                 \n\
            uniform sampler2D uSampler;                                                 \n\
            uniform vec2 increment;                                                     \n\
                                                                                        \n\
            void main(void) {                                                           \n\
                vec4 w = 1.732176555 * texture2D(uSampler, vTextureCoord);              \n\
                vec2 im = vTextureCoord - increment;                                    \n\
                vec2 ip = vTextureCoord + increment;                                    \n\
                w -= 0.464135309 * (texture2D(uSampler,im)+texture2D(uSampler,ip));     \n\
                im -= increment; ip += increment;                                       \n\
                w += 0.124364681 * (texture2D(uSampler,im)+texture2D(uSampler,ip));     \n\
                im -= increment; ip += increment;                                       \n\
                w -= 0.033323416 * (texture2D(uSampler,im)+texture2D(uSampler,ip));     \n\
                im -= increment; ip += increment;                                       \n\
                w += 0.008928982 * (texture2D(uSampler,im)+texture2D(uSampler,ip));     \n\
                im -= increment; ip += increment;                                       \n\
                w -= 0.002392514 * (texture2D(uSampler,im)+texture2D(uSampler,ip));     \n\
                im -= increment; ip += increment;                                       \n\
                w += 0.000641072 * (texture2D(uSampler,im)+texture2D(uSampler,ip));     \n\
                im -= increment; ip += increment;                                       \n\
                w -= 0.000171775 * (texture2D(uSampler,im)+texture2D(uSampler,ip));     \n\
                gl_FragColor = w;                                                       \n\
            }';
    var shaderCubicStr = '\
        varying vec2 vTextureCoord;                                                 \n\
        uniform vec2 nrOfPixels;                                                    \n\
        uniform mat2 rotMatrix;\n\
        uniform sampler2D uSampler;                                                 \n\
                                                                                    \n\
        void main(void) {                                                           \n\
            // shift the coordinate from [0,1] to [-0.5, nrOfPixels-0.5]            \n\
            //vec2 nrOfPixels = vec2(textureSize2D(uSampler, 0));                   \n\
            vec2 coordTex = vec3(vTextureCoord - 0.5, 1).xy + 0.5;       \n\
            coordTex.y = rotMatrix[1].y - (2.0 * rotMatrix[1].y - 1.0) * coordTex.y; \n\
            vec2 coord_grid = coordTex * nrOfPixels - 0.5;                          \n\
            vec2 index = floor(coord_grid);                                         \n\
            vec2 fraction = coord_grid - index;                                     \n\
            vec2 one_frac = 1.0 - fraction;                                         \n\
                                                                                    \n\
            vec2 w0 = 1.0/6.0 * one_frac*one_frac*one_frac;                         \n\
            vec2 w1 = 2.0/3.0 - 0.5 * fraction*fraction*(2.0-fraction);             \n\
            vec2 w2 = 2.0/3.0 - 0.5 * one_frac*one_frac*(2.0-one_frac);             \n\
            vec2 w3 = 1.0/6.0 * fraction*fraction*fraction;                         \n\
                                                                                    \n\
            vec2 g0 = w0 + w1;                                                      \n\
            vec2 g1 = w2 + w3;                                                      \n\
            vec2 mult = 1.0 / nrOfPixels;                                           \n\
            //h0 = w1/g0 - 1, move from [-0.5, nrOfVoxels-0.5] to [0,1]             \n\
            vec2 h0 = mult * ((w1 / g0) - 0.5 + index);                             \n\
            //h1 = w3/g1 + 1, move from [-0.5, nrOfVoxels-0.5] to [0,1]             \n\
            vec2 h1 = mult * ((w3 / g1) + 1.5 + index);                             \n\
                                                                                    \n\
            // fetch the four linear interpolations                                 \n\
            vec4 tex00 = texture2D(uSampler, h0 * rotMatrix);                                   \n\
            vec4 tex10 = texture2D(uSampler, vec2(h1.x, h0.y) * rotMatrix);                     \n\
            tex00 = mix(tex10, tex00, g0.x);  //weigh along the x-direction         \n\
            vec4 tex01 = texture2D(uSampler, vec2(h0.x, h1.y) * rotMatrix);                     \n\
            vec4 tex11 = texture2D(uSampler, h1 * rotMatrix);                                   \n\
            tex01 = mix(tex11, tex01, g0.x);  //weigh along the x-direction         \n\
            gl_FragColor = mix(tex01, tex00, g0.y);  //weigh along the y-direction  \n\
        }';
    var shaderSimpleStr = '\
        varying vec2 vTextureCoord;                                                 \n\
        uniform mat2 rotMatrix;\n\
        uniform sampler2D uSampler;                                                 \n\
        void main(void) {                                                           \n\
            vec2 coordTex = vec3(vTextureCoord - 0.5, 1).xy + 0.5;       \n\
            coordTex.y = rotMatrix[1].y - (2.0 * rotMatrix[1].y - 1.0) * coordTex.y; \n\
            gl_FragColor.rgb = pow(texture2D(uSampler, coordTex * rotMatrix).rgb, vec3(1.0/1.8));                           \n\
        }';
      var shaderVertexStr = '\
          attribute vec2 aTextureCoord;                                               \n\
          varying vec4 vColor;                                                        \n\
          varying vec2 vTextureCoord;                                                 \n\
                                                                                      \n\
          void main(void) {                                                           \n\
              vec2 pos = 2.0 * aTextureCoord - 1.0;                                   \n\
              gl_Position = vec4(pos.x, pos.y, 0.0, 1.0);                             \n\
              vTextureCoord = aTextureCoord;                                          \n\
          }';

      var highp = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
      var precisionTxt = (highp.precision != 0) ?
          'precision highp float;\nprecision highp sampler2D;\n' :
          'precision mediump float;\nprecision mediump sampler2D;\n';
      var fragmentPrefilter = loadShader(gl, precisionTxt+shaderPrefilterStr, gl.FRAGMENT_SHADER);
      var fragmentCubic = loadShader(gl, precisionTxt+shaderCubicStr, gl.FRAGMENT_SHADER);
      var fragmentSimple = loadShader(gl, precisionTxt+shaderSimpleStr, gl.FRAGMENT_SHADER);
      var vertexShader = loadShader(gl, shaderVertexStr, gl.VERTEX_SHADER);

      gl.shaderPrefilter = compileShader(gl, fragmentPrefilter, vertexShader);
      gl.shaderPrefilter.incrementUniform = gl.getUniformLocation(gl.shaderPrefilter, "increment");
      gl.shaderCubic = compileShader(gl, fragmentCubic, vertexShader);
      gl.shaderCubic.nrOfPixelsUniform = gl.getUniformLocation(gl.shaderCubic, "nrOfPixels");
      gl.shaderSimple = compileShader(gl, fragmentSimple, vertexShader);
    }

function initTextureCoordBuffer(gl) {
    gl.textureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.textureCoordBuffer);
    var textureCoords = [1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
    gl.textureCoordBuffer.itemSize = 2;
    gl.textureCoordBuffer.numItems = 4;
}

function initTextureFramebuffer(gl, width, height) {
    var rttFramebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);

    var rttTexture = gl.createTexture();
    rttTexture.width = width;
    rttTexture.height = height;
    gl.bindTexture(gl.TEXTURE_2D, rttTexture);
    var extFloat = gl.getExtension('OES_texture_float') && gl.getExtension('OES_texture_float_linear');
    var extFloatBuffer = gl.getExtension('WEBGL_color_buffer_float');
    var extHalfFloat = gl.getExtension('OES_texture_half_float') && gl.getExtension('OES_texture_half_float_linear');
    var extHalfFloatBuffer = gl.getExtension('EXT_color_buffer_half_float');
    var texType = (extFloat && extFloatBuffer) ? gl.FLOAT : ((extHalfFloat && extHalfFloatBuffer) ? extHalfFloat.HALF_FLOAT_OES : gl.UNSIGNED_BYTE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, texType, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rttTexture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return { 'framebuffer': rttFramebuffer, 'texture': rttTexture };
}

function prefilterX(gl, width, height) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, gl.rttFramebufferTextureX.framebuffer);
    gl.viewport(0, 0, width, height);
    gl.useProgram(gl.shaderPrefilter);
    gl.uniform2f(gl.shaderPrefilter.incrementUniform, 1.0 / width, 0.0);

// XXX texture was bound from C++
//    gl.activeTexture(gl.TEXTURE0);
//    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    drawTexture(gl, gl.shaderPrefilter);
}

function prefilterY(gl, width, height) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, gl.rttFramebufferTextureY.framebuffer);
    gl.viewport(0, 0, width, height);
    gl.useProgram(gl.shaderPrefilter);
    gl.uniform2f(gl.shaderPrefilter.incrementUniform, 0.0, 1.0 / height);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, gl.rttFramebufferTextureX.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    drawTexture(gl, gl.shaderPrefilter);
}

function cubicFilter(gl, texture, srcw, srch, width, height) {
    //
    // Maintain source aspect ratio
    //
    let ratio = srcw / srch
    let offx = 0
    let offy = 0
    if (ratio * height <= width) {
      offx = (width - height * ratio) / 2
      width = height * ratio
    } else {
      offy = (height - width / ratio) / 2
      height = width / ratio
    }
    let vpw = width * texture.width / srcw
    let vph = height * texture.height / srch
    let vpx = offx
    let vpy = offy + height - vph
    //
    // Draw final image
    gl.bindFramebuffer(gl.FRAMEBUFFER, gl.buffer);
    gl.viewport(vpx, vpy, vpw, vph);
    gl.useProgram(gl.shaderCubic);
    gl.uniform2f(gl.shaderCubic.nrOfPixelsUniform, texture.width, texture.height);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

    drawTexture(gl, gl.shaderCubic);
}
function simpleDraw(gl, srcw, srch, width, height) {
    //
    // Maintain source aspect ratio
    //
    let ratio = srcw / srch
    let offx = 0
    let offy = 0
    canvas.rotated = false
    if (ratio * height <= width) {
      offx = (width - height * ratio) / 2
      width = height * ratio
    } else if (!gl.neverRotate && ratio * width <= height) {
      let tmp = height
      height = width
      width = tmp

      offx = (width - height * ratio) / 2
      width = height * ratio
      canvas.rotated = true
    } else {
      offy = (height - width / ratio) / 2
      height = width / ratio
    }
    let vpw = width
    let vph = height
    let vpx = offx
    let vpy = offy + height - vph
    if (canvas.rotated) {
      let tmp = vpw
      vpw = vph
      vph = tmp
      vpy = offx
      vpx = offy
    }
    //
    // Draw final image
    gl.bindFramebuffer(gl.FRAMEBUFFER, gl.buffer);
    gl.viewport(vpx, vpy, vpw, vph);
    gl.useProgram(gl.shaderSimple);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

    drawTexture(gl, gl.shaderSimple, canvas.rotated);
}
function drawTexture(gl, shader, rotate) {
    const matrix = rotate ? new Float32Array([0.0, 1.0, 1.0, 0.0]) : new Float32Array([1.0, 0.0, 0.0, 1.0])
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform1i(shader.samplerUniform, 0);
    gl.uniformMatrix2fv(shader.rotMatrixUniform, false, matrix)

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.textureCoordBuffer);
    gl.vertexAttribPointer(gl.textureCoordAttribute, gl.textureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, gl.textureCoordBuffer.numItems);
}

      var Module = {
        preRun: [],
        postRun: [],
        print: (function() {
          var element = document.getElementById('output');
          if (element) element.value = ''; // clear browser cache
          return function(text) {
            if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
            // These replacements are necessary if you render to raw HTML
            //text = text.replace(/&/g, "&amp;");
            //text = text.replace(/</g, "&lt;");
            //text = text.replace(/>/g, "&gt;");
            //text = text.replace('\n', '<br>', 'g');
            console.log(text);
            if (element) {
              element.value += text + "\n";
              element.scrollTop = element.scrollHeight; // focus on bottom
            }
          };
        })(),
        printErr: function(text) {
          if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
          console.error(text);
        },
        canvas: (function() {
          var canvas = document.getElementById('canvas');

          // As a default initial behavior, pop up an alert when webgl context is lost. To make your
          // application robust, you may want to override this behavior before shipping!
          // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
          canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);

          return canvas;
        })(),
        setStatus: function(text) {
          if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
          if (text === Module.setStatus.last.text) return;
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon
          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2])*100;
            progressElement.max = parseInt(m[4])*100;
            progressElement.hidden = false;
            spinnerElement.hidden = false;
          } else {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;
            if (!text) spinnerElement.style.display = 'none';
            if (!text) canvas.style.visibility = '';
          }
          statusElement.innerHTML = text;
        },
        initGL: function(width, height) {
        /*
          const gl = canvas.GLctxObject.GLctx
          gl.neverRotate = !isMobile()
          initShaders(gl)
          initTextureCoordBuffer(gl)
          gl.rttFramebufferTextureX = initTextureFramebuffer(gl, width, height);
          gl.rttFramebufferTextureY = initTextureFramebuffer(gl, width, height);
        */
        },
        renderTexture: function(w, h) {
        /*
          const gl = canvas.GLctxObject.GLctx
          if (canvas.width != canvas.clientWidth * devicePixelRatio || canvas.height != canvas.clientHeight * devicePixelRatio) {
            canvas.width = canvas.clientWidth * devicePixelRatio
            canvas.height = canvas.clientHeight * devicePixelRatio
          }
          //prefilterX(gl, 1366, 768);
          //prefilterY(gl, 1366, 768);
          //cubicFilter(gl, gl.rttFramebufferTextureY.texture, w, h, canvas.width, canvas.height);
          simpleDraw(gl, w, h, canvas.width, canvas.height);
        */
        },
        ingameWidth: function() {
          if (isMobile()) return 848;
          else return 1024;
        },
        ingameHeight: function() {
          if (isMobile()) return 480;
          else return 768;
        },
		shouldStretch: function() {
		  if (location.search.indexOf('nowidescreen') < 0) return true;
		  else return false;
		},
        shouldRotate: function() {
            return isMobile()
        },
        totalDependencies: 0,
        monitorRunDependencies: function(left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? 'Downloading... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
        }
      };
      canvas.style.visibility = 'hidden';
      Module.setStatus('Downloading...');
      window.onerror = function(message, source, lineno, colno, error) {
        // TODO: do not warn on ok events like simulating an infinite loop or exitStatus
        Module.setStatus('Exception thrown, see JavaScript console');
        spinnerElement.style.display = 'none';
        Module.setStatus = function(text) {
          if (text) Module.printErr('[post-exception status] ' + text);
        };
        canvas.style.visibility = 'hidden';
        document.write(message);
        document.write(error.stack);
      };

      function doFullscreen() {
        canvas.requestFullscreen()
      }

      function isMobile() {
        return navigator.userAgent.indexOf('Mobile') >= 0 || navigator.userAgent.indexOf('Android') >= 0
      }

      if (isMobile()) {
        canvas.addEventListener('touchstart', (e) => {
          if (!document.fullscreenElement) {
            canvas.requestFullscreen && canvas.requestFullscreen()
            canvas.webkitRequestFullScreen && canvas.webkitRequestFullScreen()
          }
        }, true)
        canvas.addEventListener('touchmove', (e) => {
        }, true)
        canvas.addEventListener('touchend', (e) => {
        }, true)
      }

      function doit() {
        var script = document.createElement('script')
        script.type = 'text/javascript'
        script.src = 'out.js'
        document.body.appendChild(script)
        warning.style.display = 'none'
        localStorage.setItem('warning-accepted', 1);
      }

      if (localStorage.getItem('warning-accepted')) {
        doit()
      } 
    </script>
  </body>
</html>


